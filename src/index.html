<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="shortcut icon" href="#">

    <script type="text/javascript" src="../libraries/jquery-2.2.2/http_code.jquery.com_jquery-2.2.2.js"></script>
    <script type="text/javascript" src="../libraries/jquery-ui/http_code.jquery.com_ui_1.11.4_jquery-ui.js"></script>
    <script type="text/javascript" src="../libraries/jquery-ui-touch-punch/jquery.ui.touch-punch.min.js"></script>
    <script type="text/javascript" src="../libraries/gsap/http_cdnjs.cloudflare.com_ajax_libs_gsap_1.20.4_TweenMax.min.js"></script>
</head>
<style>

</style>
<body>
<div id="board-wrapper-wrapper">
    <div id="board-wrapper">
        <div id="board"></div>
    </div>
</div>
</body>

<script src="pieces/piece.js"></script>
<script src="pieces/pawn.js"></script>
<script src="pieces/knight.js"></script>
<script src="pieces/bishop.js"></script>
<script src="pieces/rook.js"></script>
<script src="pieces/queen.js"></script>
<script src="pieces/king.js"></script>

<script src="square.js"></script>
<script src="board.js"></script>

<script>
    const squares = $('chess-square');
    const itemContainer = squares;
    const moveType = {
        capture: '../assets/sound/capture.webm',
        castle: '../assets/sound/castle.webm',
        gameEnd: '../assets/sound/game-end.webm',
        gameStart: '../assets/sound/game-start.webm',
        illegal: '../assets/sound/illegal.webm',
        moveCheck: '../assets/sound/move-check.webm',
        moveOpponent: '../assets/sound/move-opponent.webm',
        moveSelf: '../assets/sound/move-self.webm',
        promote: '../assets/sound/promote.webm'
    }

    let enemyKing;
    let king;

    let currentHints = [];
    let currentActive;
    let previousMove;

    itemContainer.sortable({
        connectWith: squares,
        containment: $('#board-wrapper'),
        items: $('.piece'),
        cursor: "grabbing",
        tolerance: "pointer",
        start: function (e) {
            clearCurrentHints();
            clearCurrentActive();
            getMoves(e.target);
        },
        over: function (e) {
            e.target.classList.add("hover");
        },
        out: function (e) {
            e.target.classList.remove("hover");
        },
        receive: function (e, ui) {
            const newPos = e.target;
            const prevPos = ui.sender;
            const piece = ui.item[0];

            if (!newPos.querySelectorAll(".hint, .capture-hint").length) {
                prevPos.sortable("cancel");
                return;
            }

            if (piece instanceof Pawn && (newPos.y === 7 || newPos.y === 0)) {
                clearCurrentHints();
                newPos.addPromotionMenu(piece.white).then(function (piece) {
                    if (piece === undefined) {
                        prevPos.sortable("cancel");
                    } else {
                        piece.classList.remove("promotion-option");
                        makeMove(prevPos[0], newPos, piece, moveType.promote);
                        resetOnClick();
                    }
                });

            } else {
                makeMove(prevPos[0], newPos, piece, newPos.piece === null ? moveType.moveSelf : moveType.capture);
            }
        }
    });

    function resetOnClick() {
        let pieces = $('.piece');

        pieces.on("click", function (e) {
            clearCurrentHints();
            clearCurrentActive();
            getMoves(e.target.parentNode);
        });

        itemContainer.sortable("option", "items", pieces);
    }

    resetOnClick();

    function makeMove(prevPos, newPos, piece, type) {
        prevPos.removePiece();
        newPos.removePiece();
        newPos.addPiece(piece);

        if (enemyKing.isInCheck()) type = moveType.moveCheck;

        new Audio(type).play();

        removeEnPassant();
        checkEnPassant(prevPos, newPos, piece);

        swapPreviousMove(prevPos, newPos);

        clearCurrentHints();
        clearCurrentActive();
        printBoard();
    }

    function getKing(white) {
        return $('chess-king.' + (white ? 'white' : 'black'))[0];
    }

    function getMoves(square) {
        let piece = square.piece;

        enemyKing = getKing(!piece.white);
        king = getKing(piece.white);

        let moves = piece.getMoves(square.y, square.x);
        let rect = piece.getBoundingClientRect();

        square.classList.add("currentMove");
        currentActive = square;

        for (let move of moves) {
            move.square.addHint(piece.white);

            $(move.square).on("click", function () {
                const newPos = this;
                const prevPos = square;

                if (piece instanceof Pawn && (newPos.y === 7 || newPos.y === 0)) {
                    clearCurrentHints();
                    piece.remove();

                    this.addPromotionMenu(piece.white).then(function (value) {
                        if (value === undefined) {
                            prevPos.appendChild(piece);
                        } else {
                            value.classList.remove("promotion-option");
                            makeMove(prevPos, newPos, value, moveType.promote);
                            resetOnClick();
                        }
                    });
                } else {
                    makeMove(prevPos, newPos, piece, move.capture ? moveType.capture : moveType.moveSelf);

                    TweenMax.set(piece, {x: 0, y: 0});

                    let newRect = piece.getBoundingClientRect();

                    TweenMax.from(piece, 0.2, {
                        x: rect.left - newRect.left,
                        y: rect.top - newRect.top,
                        ease: Power3.linear,
                        onComplete: () => piece.style.zIndex = "1"
                    });
                }
            });
        }

        currentHints = moves;
    }

    function clearCurrentHints() {
        for (let hint of currentHints) {
            hint.square.removeHint();
            $(hint.square).unbind("click");
        }
        currentHints = [];
    }

    function clearCurrentActive() {
        if (currentActive !== undefined) {
            currentActive.classList.remove("currentMove");
            currentActive = undefined;
        }
    }

    let currentEnPassant;

    function checkEnPassant(prevPos, newPos, piece) {
        if (!(piece instanceof Pawn)) return;
        if (Math.abs(prevPos.y - newPos.y) !== 2) return;

        if (prevPos.y === 1) {
            currentEnPassant = board[prevPos.y + 1][prevPos.x]
        } else {
            currentEnPassant = board[prevPos.y - 1][prevPos.x]
        }

        currentEnPassant.addEnPassant(piece.white);
    }

    function removeEnPassant() {
        if (!(currentEnPassant instanceof Square)) return;

        if (currentEnPassant.piece === null) return;

        if (currentEnPassant.piece.getPieceLetter === "e") currentEnPassant.piece = null;
    }

    function swapPreviousMove(prevPos, newPos) {
        if (previousMove !== undefined) {
            previousMove.prevPos.classList.remove("previousMove");
            previousMove.newPos.classList.remove("previousMove");
        }

        prevPos.classList.add("previousMove");
        newPos.classList.add("previousMove");
        previousMove = {
            prevPos: prevPos,
            newPos: newPos,
        }
    }

    printBoard();
</script>
</html>
